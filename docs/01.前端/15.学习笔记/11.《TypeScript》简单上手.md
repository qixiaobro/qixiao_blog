---
title: 《TypeScript》简单上手
date: 2020-11-22 15:45:26
permalink: /pages/26a132/
categories:
  - 前端
  - 学习笔记
tags:
  -
---

`TypeScript`是一门强类型语言，是`JavaScript`的超集。同时是一门渐进式的语言，可以不用深入学习即可上手。

## 原始数据类型

### `string`

```ts
const a: string = '1'
```

### `number`

```ts
const b: number = 1 //同时也可以是NaN Infinity
```

### `boolean`

```ts
const c: boolean = true //false
```

### `void`

```ts
const d: void = undefined //严格模式只能存undefined,非严格模式可以是null
```

### `null`

```ts
const e: null = null
```

### `undefined`

```ts
const f: undefined = undefined
```

### `symbol`

```ts
const g: symbol = Symbol() //仅在target为ES2015以上才行
```

## `module scoped`

在两个不同文件定义了两个重名变量，怎么办。

1. 使用立即执行函数

```ts
;(function() {
  const a = 123
})()
```

2. 使用`export`

```ts
export {}
```

## `Object`类型

::: tip
`Object`类型包含所有非原始类型！！并不单指对象
:::

- 可以是所有非原始类型

```ts
const foo: Object = function() {}
```

- 单指对象需使用字面量的方式定义

```ts
const bar: {} = {}
```

- 对象里必须有一个 foo 属性且是字符串

```ts
const bar: { foo: string } = { foo: '123' }
```

## 数组类型

```ts
const a: Array<number> = [1, 2, 3]

const b: number[] = [1, 2, 3] //常用方式

const c: Array<object> = []
```

函数指定参数数组类型

```ts
function sum(...args: number[]) {
  return args.reduce((prev, current) => prev + current, 0)
}

sum(1, 2, 3, 'foo') //会报错 “类型"foo"的参数不能赋给类型“number”的参数。”
```

## 元组

元组类型允许表示一个<mark>已知元素数量和类型</mark>的数组，各元素的类型不必相同。

```ts
const tuple: [string, number] = ['str', 1]

//取值
const a = tuple[0]
//解构赋值
const { str, num } = tuple
```

## 枚举

使用枚举可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。
:::warning
会入侵编译后的代码
:::

```ts
enum PostStatus {
  Draft = 0,
  Unpublished = 1,
  Published = 2,
}
```

- 可以不用等号赋值，默认从 0 开始累加

```ts
enum PostStatus {
  Draft,
  Unpublished,
  Published,
}
```

- 也可以赋第一个值，然后后续会累加，`Unpublished = 7，Published = 8`

```ts
enum PostStatus {
  Draft = 6,
  Unpublished,
  Published,
}
```

- 也可以是字符串，但是就不能累加

```ts
enum PostStatus {
  Draft = 'a',
  Unpublished = 'b',
  Published = 'c',
}
```

### 常量枚举

不会入侵编译后的代码

```ts
const enum PostStatus2 {
  Draft = 0,
  Unpublished = 1,
  Published = 2,
}

const post2 = {
  title: 'hello ts',
  content: 'awesome',
  status: PostStatus2.Draft,
}
```

## 函数类型

- 定义函数

```ts
function func1(a: number, b: number) {
  return 'func1'
}

func1(100, 100)
```

- 可选参数

```ts
function func2(a: number, b?: number) {
  return 'func2'
}

func2(100, 100)
func2(100)
```

- 参数默认值

```ts
function func3(a: number, b: number = 100) {
  return 'func3'
}

func3(100, 100)
func3(100)
```

- 多余参数

```ts
function func4(a: number, b: number = 100, ...rest: number[]) {
  return 'func4'
}

func4(100, 100, 100, 100)
```

### 声明式写法

为常量定义类型

```ts
//定义一个函数，此函数接收两个number类型的参数，并返回一个字符串
const func5: (a: number, b: number) => string = function(a: number, b: number) {
  return 'func5'
}
```

## `any`类型

在编程阶段还不清楚类型的变量指定一个类型

```ts
function stringify(value: any) {
  return JSON.stringify(value)
}

stringify(100)

stringify('str')

stringify(true)

let foo: any = 'a'
foo = 1
```

## 隐式类型推断

在初始化变量和成员，设置默认参数值和决定函数返回值时，不指定类型，会自动推断类型。

```ts
let age = 18

age = 'str' //报错 不能将类型“"str"”分配给类型“number”。

let foo //这种情况下，则自动推断为any类型

foo = 1

foo = 'str'
```

## 断言

你清楚地知道一个实体具有比它现有类型更确切的类型。通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。

```ts
const nums: number[] = [1, 2, 3]

const res = nums.find(i => i > 1) //编译器会认为 res 的类型为 number | undefined
```
1. 通过关键字`as` 断言
```ts
const num1 = res as number
```

2. 通过`<>`断言
:::warning 
在JSX语法里不可使用，跟标签冲突
:::
```ts
const num2 = <number>res
```

## 接口
用来制定一个类型的规则

```ts
interface Post {
 title: string
 content: string
 subtitle?: string //可选成员
 readonly summary: string //只读成员
}

function printPost(post: Post) {
 console.log(post.title)
 console.log(post.content)
}

printPost({
 title:'ass',
 content:'aaaa',
 summary:'sss'
})
```

* 动态成员
```ts
interface Cache {
 [prop: string]: string
}

const cache: Cache = {}
cache.foo = '11'
cache.bar = '22'
```

