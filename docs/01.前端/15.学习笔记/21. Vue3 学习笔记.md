---
title: Vue3学习笔记
date: 2020-11-24 16:08:22
permalink: /pages/d4fdaa/
categories:
  - 前端
  - 学习笔记
tags:
  - Vue3
---

2020 年 09 月 18 日，终于。。`Vue.js 3.0`正式版发布了。
扶我起来，我还能学！
这里展示学习`Vue.js 3.0`新增特性和变更的特性的所有 demo

## 响应性

`Vue.js 3.0`的数据监听使用`ES6`新特性`Proxy`重写了。使得对对象、数组等数据结构的操作监听更加强大。
其中`Vue.js 3.0`新增了许多响应性 API，这里展示几个常用的。

### `reactive`

为 `JavaScript` 对象创建响应式状态

```js
import { reactive } from 'vue'

const state = reactive({
  count: 0,
})
```

:::warning
响应式转换是“深层”的——它影响所有嵌套 `property`。在基于 `ES2015 Proxy` 的实现中，返回的 `proxy` 是不等于原始对象的。建议只使用响应式 `proxy`，避免依赖原始对象。
:::
即

```js
const state = { count: 0 }
const state2 = reactive(state)
console.log(state === state2) //false
```

### `ref`

让一个原始值变成响应式

```js
import { ref } from 'vue'

const count = ref(0)
```

使用`ref`API,会返回一个可变的响应式对象，该对象作为它的内部值——一个响应式的引用。在`setup()`API 里需使用`.value`来访问,在实例创建完后，则可以直接使用
`this.count`访问

```js
//setup()
console.log(count.value) //0

//other
console.log(this.count) //0
```

#### `ref`展开

当 `ref` 作为渲染上下文 (从 `setup()` 中返回的对象) 上的 `property` 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加 `.value`：

```html
<span>count:{{count}}</span>
<!--模版中会自动展开，不需要.value-->
```

#### 访问响应式对象

```js
const count = ref(0)
const state = reactive({
  count,
})

console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1
```

如果将新的 ref 赋值给现有 ref 的 property，将会替换旧的 ref：

```js
const otherCount = ref(2)

state.count = otherCount
console.log(state.count) // 2
console.log(count.value) // 1
```

:::right
[在 codeOpen 里尝试上述 demo](https://codepen.io/qixiaobro/pen/WNGeXXE)
:::
:::warning
`ref` 展开仅发生在被响应式 `Object` 嵌套的时候。当从 `Array` 或原生集合类型如 `Map`访问 `ref` 时，不会进行展开,需要使用`.value`访问
:::

```js
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```

### 响应式状态解构

:::warning
响应式对象如果解构，会导致响应性丢失。
:::

```js
const book = reactive({
  author: 'Vue Team',
  year: '2020',
  title: 'Vue 3 Guide',
  description: 'You are reading this book right now ;)',
  price: 'free',
})
let { author } = book
book.author = 'zxd'
console.log(book.author) //zxd
console.log(author) //"Vue Team"
```

#### 解决办法

##### `toRef`

为单个属性保持响应式连接。

```js
const year = toRef(book, 'year')
book.year = '2021'
console.log(year.value) //2021  需使用.value方式访问
console.log(book.year) //2021

//当您要将 prop 的 ref 传递给复合函数时，toRef 很有用：
export default {
  setup(props) {
    useSomeFeature(toRef(props, 'title'))
  },
}
```

##### `toRefs`

为一组属性保持响应式连接

```js
let { title, price } = toRefs(book)

book.title = 'toRefs'
book.price = 'noFree'

console.log(title.value) //"toRefs"
console.log(price.value) //"noFree"
console.log(book.title) //"toRefs"
console.log(book.price) //"noFree"
```

### readonly

防止更改响应式对象

```js
const original = reactive({ count: 0 })

const copy = readonly(original)

original.count++

copy.count++ // 警告 "Set operation on key 'count' failed: target is readonly."
```

:::right
[在 codeOpen 里尝试上述 demo](https://codepen.io/qixiaobro/pen/mdrbzdK)
:::

### watchEffect

立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。

```js
const count = ref(0)

const stop = watchEffect(() => console.log(count.value)) //0

setTimeout(() => {
  count.value++
}, 100) //1
```

#### 停止侦听

```js
setTimeout(() => {
  stop()
  count.value++
}, 200) //无输出
```

#### 清除副作用

有时候我们会通过监听变量，来发起请求，获取数据。但是有可能在请求返回数据之前，变量又发生了改变或者停止了侦听。那么上一次返回的数据就是脏数据，会导致界面展示错误等问题。通过`watchEffect`就可以减少调用

我们可以通过传入`onInvalidate` 函数作入参，用来注册清理失效时的回调。
这个回调触发时机：
* 副作用即将重新执行时
* 侦听器被停止 (如果在 `setup()` 或生命周期钩子函数中使用了 `watchEffect`，则在组件卸载时)

```js
watchEffect(onInvalidate => {
  const token = performAsyncOperation(id.value)
  onInvalidate(() => {
    // id has changed or watcher is stopped.
    // invalidate previously pending async operation
    token.cancel() //取消api的调用
  })
})

//通常是异步的
const data = ref(null)
watchEffect(async onInvalidate => {
  onInvalidate(() => {...}) // 我们在Promise解析之前注册清除函数
  data.value = await fetchData(props.id)
})
```


#### 副作用刷新时机
当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 `update` 前执行

如果需要在组件更新后重新运行侦听器副作用，我们可以传递带有 flush 选项的附加 `options` 对象 (默认为 `'pre'`)：
```js
// 在组件更新后触发，这样你就可以访问更新的 DOM。
// 注意：这也将推迟副作用的初始运行，直到组件的首次渲染完成。
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'post'
  }
)
```

#### 侦听器调试
`onTrack` 和 `onTrigger` 选项可用于调试侦听器的行为。

`onTrack` 将在响应式 `property` 或 `ref` 作为依赖项被追踪时被调用。
`onTrigger` 将在依赖项变更导致副作用被触发时被调用。
这两个回调都将接收到一个包含有关所依赖项信息的调试器事件。建议在以下回调中编写 `debugger` 语句来检查依赖关系
```js
watchEffect(
  () => {
    /* 副作用 */
  },
  {
    onTrigger(e) {
      debugger
    }
  }
)
```

### watch
`watch`跟vue2的用法差不多，需要指定特定的侦听数据源。
与 `watchEffect` 比较，`watch` 允许我们：

* 执行副作用；
* 更具体地说明什么状态应该触发侦听器重新运行；
* 访问侦听状态变化前后的值。


#### 侦听单个数据源
```js
// 侦听一个 getter,直接侦听一个对象的属性值
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)

// 直接侦听ref
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
```
#### 侦听多个数据源
```js
watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
  /* ... */
})
```
:::right
[在 codeOpen 里尝试上述 demo](https://codepen.io/qixiaobro/pen/MWjWWyv)
:::


# 组合式`API`

## setup()

### 参数

```js
setup(props, context)
```

### `props`

:::warning
props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。
:::

### `context`

context:非响应书，可以使用 ES6 解构
attrs、slot、emit
attrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 property。请注意，与 props 不同，attrs 和 slots 是非响应式的。如果你打算根据 attrs 或 slots 更改应用副作用，那么应该在 onUpdated 生命周期钩子中执行此操作。

### 返回渲染函数

### 生命周期钩子

### 提供/注入

### `provide`

name、value

### `inject`

name、value(可选)

### 响应性

ref
reactive

#### 修改响应式`property`

在提供者内保持响应式`property`的任何更改、提供一个修改方法注入到组件内部
`readonly`

### 模板引用

如果 VNode 的 ref 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。这是在虚拟 DOM 挂载/打补丁过程中执行的，因此模板引用只会在初始渲染之后获得赋值。

#### `JSX` 中的用法

#### `v-for`中的用法
           
## `Teleport`
将组件挂载在`id="app"`外的指定Dom上。

## 触发组件选项
